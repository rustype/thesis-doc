%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% chapter4.tex
%% NOVA thesis document file
%%
%% Chapter with lots of dummy text
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE chapter4.tex}

\chapter{The \annotation{typestate} macro}\label{cha:macro}

I now present the core contribution of this thesis, the \annotation{typestate} macro.
In \autoref{sec:typestates-hard-way}, I start by demonstrating how to implement Rust typestates by hand.
In \autoref{sec:macro-dsl:architecture} I discuss the macro high-level architecture,
the DSL is discussed in \autoref{sec:macro-dsl},
followed by the validation process in \autoref{sec:validation} and
extra features offered by the macro in \autoref{sec:extra-features}.

\section{Typestates: The Hard Way}\label{sec:typestates-hard-way}

In this section I demonstrate the development process from a state machine specification to a functional prototype,
developing all the required components by hand.
The example will be a vending machine, its automaton is illustrated in \autoref{fig:vending-machine}.
To simplify the example, consider the following:
\begin{compactitem}
    \item The machine houses an infinite stock of each of the available snacks.
    \item Each snack is addressed by its index and the only information available about it is its price.
    \item The machine does not make change.
\end{compactitem}

% TODO maybe add an ingredients subsubsection

\input{Chapters/Figures/C4/vending-machine.tex}

We start by designing our \emph{typestated} structure, the \texttt{VendingMachine};
to do so, we will use a \texttt{State} generic type parameter to model the current state.

\begin{minted}[linenos=false]{rust}
struct VendingMachine<State>;
\end{minted}

However, since \texttt{State} is an unused type parameter the compiler issue an error;
we can fix the error in one of two ways:
\begin{compactitem}
    % TODO PhantomData needs background
    \item Declaring a \texttt{PhantomData}\footnotemark~field using \texttt{State} as its type parameter.
    This approach is useful if the types used in \texttt{State} do not carry more information other than its type.
    \begin{minted}[linenos=false]{rust}
struct VendingMachine<State> { state: PhantomData<State> }
    \end{minted}
    \item Declaring a field of type \texttt{State}.
    This approach allows us to use more information other than its type alone, such as structure fields.
    \begin{minted}[linenos=false]{rust}
struct VendingMachine<State> { state: State }
    \end{minted}
\end{compactitem}
\footnotetext{
    \texttt{PhantomData} is a zero-sized type used to \quotes{pretend} that it owns a previously-unused type parameter (or lifetime).
    This is required since Rust's compiler will complain in the case that a type parameter is unused. % NOTE this is kinda repeated
    To know more about \texttt{PhantomData},
    please refer to its documentation page --- \url{https://doc.rust-lang.org/std/marker/struct.PhantomData.html};
    or to its page on \emph{The Rustonomicon} --- \url{https://doc.rust-lang.org/nomicon/phantom-data.html}.
}

There are cases where all states are simply markers \ie{do not carry additional information},
however, consider that the vending machine is required to keep track of both the client's pick along with the inserted money so far.
Given we are modelling our machine \quotes{by states},
we should not be required to track neither of those in the initial or final states \ie{\texttt{Waiting} and \texttt{Finish}, respectively}.
With that in mind, we are required to take the second approach, enabling states to have inner values.

While our vending machine is now able to deal with the concept of state,
it is unable to sell anything, we need some place to store the items available for sale and all the money we made.
We will use a vector for the items and an unsigned 64-bit integer for monetary values, see \autoref{lst:vending-machine-struct}.
These values are available for any state, as they are \quotes{part of the machine} and not specific to a given state.

\begin{listing}
    \begin{minted}{rust}
struct VendingMachine<State> {
    /// The money made so far.
    balance: u64,
    /// The available item's prices.
    items: Vec<u64>,
    /// The current machine state.
    state: State,
}
\end{minted}
    \caption{The vending machine main \texttt{struct}.}
    \label{lst:vending-machine-struct}
\end{listing}

Currently, we have a machine supporting states, but no states.
To address this we need to declare each state as a structure;
each structure can then contain its own fields, only available for that state.

Looking back at \autoref{fig:vending-machine}, we can infer the following:
\begin{compactitem}
    \item The \texttt{Waiting} and \texttt{Finish} states do not require any fields.
    \item The \texttt{HasMoney} and \texttt{HasPick} states require their own fields,
    the money inserted so far and the slot picked by the client, respectively.
    \item The \texttt{NeedMoney} state requires both the money and picked slot.
\end{compactitem}

The states' structure declarations are listed and documented in \autoref{lst:vending-machine-states}.

\begin{listing}
    \begin{minted}{rust}
/// The machine is waiting for interaction.
struct Waiting;
/// The machine has received some amount of money
struct HasMoney {
    /// The insert amount of money
    money: u64
}
/// The machine has received a slot pick.
struct HasPick {
    /// The selected slot.
    picked_slot: usize
}
/// The machine has received both money and a slot pick,
/// but not enough money to complete the purchase.
struct NeedMoney {
    money: u64,
    picked_slot: usize
}
/// The purchase is complete.
struct Finish;
\end{minted}
    \caption{The vending machine's states, as illustrated in \autoref{fig:vending-machine}.}
    \label{lst:vending-machine-states}
\end{listing}

Moving on to transitions, we need to ensure that there are no aliases to the current state;
Rust's borrow checker helps us achieve that goal,
we can restrict the usage of the current state to only be possible in the case \keyword{self} is owned,
the borrow checker will then make sure that is true when time comes to use the method.

To declare a transition, we first open an \keyword{impl}\footnotemark~block which will contain our transition,
the block will implement a concrete state of the state machine by specifying the generic type parameter to be one of the declared states, line 1 of \autoref{lst:vending-machine-state-impl};
inside the block, we declare the transition function, it will take \keyword{self} as a first parameter, consuming the first state, and return the next state;
exemplified in lines 4 \& 5 of \autoref{lst:vending-machine-state-impl}.
\footnotetext{
    The \keyword{impl} keyword is used for implementation blocks, whether it is for inherent or trait implementations.
    For further details, refer to \emph{The Rust Reference} --- \url{https://doc.rust-lang.org/reference/items/implementations.html}.
}

\begin{listing}
    \begin{minted}{rust}
impl VendingMachine<Waiting> {
    fn on() -> Self { /* ... */ }
    fn off(self) { /* ... */ }
    fn insert_money(self, money: u64) -> VendingMachine<HasMoney> { /* ... */ }
    fn pick_slot(self, picked_slot: usize) -> VendingMachine<HasPick> { /* ... */ }
}
\end{minted}
    \caption[test]{The vending machine's \texttt{Waiting} implementation\footnotemark.}
    \label{lst:vending-machine-state-impl}
\end{listing}
\footnotetext{
    \keyword{Self} is a keyword which acts as a type alias to the \quotes{current} type,
    it is native to Rust and works in the context of traits and their implementations.
    In \autoref{lst:vending-machine-state-impl} the \keyword{Self} will refer to \texttt{VendingMachine<Waiting>}.
    For more information on \keyword{Self}, refer to \url{https://doc.rust-lang.org/std/keyword.SelfTy.html}
}

To better understand what is going on, lets implement the \texttt{insert\_money} transition;
all we need to do is simply transition from the \texttt{Waiting} state (declared as the generic parameter in line 1 of \autoref{lst:vending-machine-waiting-insert-money}),
to the \texttt{HasMoney} state, declared as the generic parameter of the \texttt{VendingMachine} return type, line 3 of \autoref{lst:vending-machine-waiting-insert-money}.

\begin{listing}
    \begin{minted}{rust}
impl VendingMachine<Waiting> {
    /// The user has inserted some amount of money into the machine.
    fn insert_money(self, money: u64) -> VendingMachine<HasMoney> {
        VendingMachine::<HasMoney> {
            contents: self.contents, // pass the machine's contents
            state: HasMoney {        // new state
                money                // pass the received money
            }
        }
    }
    // ...
}
\end{minted}
    \caption{The implementation of \texttt{insert\_money} for the machine's \texttt{Waiting} state.}
    \label{lst:vending-machine-waiting-insert-money}
\end{listing}

Before we go further, a quick recap over what has been done so far ---
we have declared the vending machine, its states and its \emph{some} of its transitions.

I say \quotes{some} transitions, because we have not addressed how the diamonds in \autoref{fig:vending-machine} work.
We use the diamonds to represent a decision between $N$ possible paths, I will refer to them as \emph{decision nodes};
this representation closely resembles \emph{Deterministic Object Automata} \cite{Trindade2020}.
To model our decision nodes, we can use Rust's enumerations,
these allow us to declare possible outcomes and force the \gls{API} client to match them.

We continue our path, following the \texttt{pick\_slot} transition from the \texttt{HasMoney} state,
we have \emph{either} the \texttt{Finish} state or the \texttt{NeedsMoney} state,
a decision node; its implementation is described in \autoref{lst:vending-machine-check-finish}.

\begin{listing}
    \begin{minted}{rust}
// To simplify naming, we reuse the state's names
enum CheckFinish {
    NeedsMoney(VendingMachine<NeedsMoney>),
    Finish(VendingMachine<Finish>),
}
\end{minted}
    \caption{Vending machine's decision node as a Rust \keyword{enum}.}
    \label{lst:vending-machine-check-finish}
\end{listing}

Using the \texttt{CheckFinish} enumeration, we are now able to properly define \texttt{HasMoney}'s \texttt{pick\_slot} function;
if the user has inserted enough money, a purchase is made (\autoref{lst:vending-machine-pick-slot} --- lines 6-13),
otherwise, the vending machine asks for more money (\autoref{lst:vending-machine-pick-slot} --- lines 14-22),
in either case, it returns a variant of the declared \keyword{enum}.

\begin{listing}
    \begin{minted}{rust}
impl VendingMachine<HasMoney> {
    fn pick_slot(self, picked_slot: usize) -> CheckFinish {
        let money = self.state.money;
        let price = self.contents[picked_slot]; // get the pick's price
        // Check if there is enough money
        if money >= price {
            // If yes, return the `Finish` state
            CheckFinish::Finish(VendingMachine::<Finish> {
                // update the machine's balance
                balance: self.balance + money,
                contents: self.contents,
                state: Finish,
            })
        } else {
            // If not, return the `NeedMoney` state
            CheckFinish::NeedMoney(VendingMachine::<NeedMoney> {
                balance: self.balance,
                contents: self.contents,
                state: NeedMoney { money, picked_slot },
            })
        }
    }
}
\end{minted}
    \caption{The \texttt{pick\_slot} implementation for the vending machine during the \texttt{HasMoney} state.}
    \label{lst:vending-machine-pick-slot}
\end{listing}

The \gls{API} client will now be required to match the enumeration,
which implies the user needs to (or at least try to) deal with all possible outcomes;
exemplified in \autoref{lst:vending-machine-check-finish-match}.

\begin{listing}
    \begin{minted}{rust}
let mut vm: CheckFinish = vm.pick_slot(0);
while let CheckFinish::NeedMoney(vm_) = vm {
    vm = vm_.insert_money(1);
}
match vm {
    CheckFinish::Finish(vm) => vm.finish().off(),
    CheckFinish::NeedMoney(_) =>
        unreachable!("if we left the loop this should be unreachable"),
}
\end{minted}
    \caption{
        Matching \texttt{CheckFinish} in two different ways;
        lines 2-4 --- using a \keyword{while} loop,
        lines 5-9 --- using common \keyword{match}.
    }
    \label{lst:vending-machine-check-finish-match}
\end{listing}

This concludes the implementation of the state machine,
the states I did not cover follow the same implementation pattern,
as the automaton is \quotes{symmetric}, although the functions perform different actions.

To test if our typestates work, we can try to call a function in a state where such function is unavailable (\autoref{lst:vending-machine-wrong-call});
this will not compile the compiler will even be helpful enough as to tell us that
\texttt{finish} was not found for the \texttt{Waiting} state (\autoref{lst:vending-machine-wrong-call-error}).

\begin{listing}
    \begin{minted}[linenos=false]{rust}
let vm = VendingMachine::<Waiting>::on() // Start the vending machine
    .finish();                           // Finish a purchase
\end{minted}
    \caption{Calling the \texttt{finish} function in the \texttt{Waiting} state.}
    \label{lst:vending-machine-wrong-call}
\end{listing}

\begin{listing}
    \begin{minted}[linenos=false]{text}
no method named `finish` found for struct `VendingMachine<Waiting>`
in the current scope items from traits can only be used if the trait is
implemented and in scope the following trait defines an item `finish`,
perhaps you need to implement it:
candidate #1: `Hasher`
\end{minted}
    \caption{The error resulting from \autoref{lst:vending-machine-wrong-call}.}
    \label{lst:vending-machine-wrong-call-error}
\end{listing}

\subsection{Future Proofing}\label{sec:typestates-hard-way:future}

Our \gls{API} seems to be rock-solid,
methods cannot be called in state they do not belong to and the compiler will even provide helpful messages.

However, there is a problem, nothing stops a developer from extending the \gls{API} by implementing a \quotes{foreign} type
(in this context, consider \quotes{foreign} to be a type which is not a state), such as the unit type --- \texttt{()}.
Disregarding the fact that implementing the unit type as a type parameter of our vending machine makes no sense;
we need to avoid these situations and to do so \emph{The Rust API Guidelines}\footnote{\url{https://rust-lang.github.io/api-guidelines/future-proofing.html\#sealed-traits-protect-against-downstream-implementations-c-sealed}} offer an answer! % CITE

We can implement the \quotes{sealed trait pattern},
which is just a way of stopping downstream users from modifying our state hierarchy.

% TODO explain the trait keyword
Following the guidelines, we need to first create a public \keyword{trait} which every state will implement (\autoref{lst:vending-machine-sealed} --- lines 13-23);
we need to further restrict the state set with a private \keyword{trait} (\autoref{lst:vending-machine-sealed} --- lines 1-11), also implemented by every state,
it is required to be private so downstream users are unable to access and implement it.

\begin{listing}
    \begin{minted}{rust}
mod private {
    /// The `Sealed` trait, unable to implemented by downstream users.
    pub trait Sealed {}

    // The trait implementations for each state.
    impl Sealed for Waiting {}
    impl Sealed for HasMoney {}
    impl Sealed for HasPick {}
    impl Sealed for NeedMoney {}
    impl Sealed for Finish {}
}

/// The `State` trait. While any user can *technically* implement it,
/// its bound requires `private::Sealed` to also be implemented,
/// which is impossible because it is not accessible to downstream users.
pub trait State: private::Sealed {}

// The `State` trait implementations.
impl State for Waiting {}
impl State for HasMoney {}
impl State for HasPick {}
impl State for NeedMoney {}
impl State for Finish {}
\end{minted}
    \caption{The implementation of the sealed trait pattern for our vending machine automaton.}
    \label{lst:vending-machine-sealed}
\end{listing}


\section{Macro DSL}\label{sec:macro-dsl}

Now that we know how to build our own typestates,
we want to automate part of the process.
While automating said process, we will add some checks to ensure our typestate adheres to a set of properties.

% The set of properties we are checking for are:
% \begin{description}
%     \item[]
% \end{description}

\subsection{Architecture}\label{sec:macro-dsl:architecture}
\input{Chapters/Figures/C4/dsl-processing.tex}
I now discuss our macro's architecture,

\subsubsection{Parsing}
% TODO: discuss the usage of syn, the visitor pattern and the typestate::generated macro

\subsection{Syntax \& Automaton Extraction}\label{sec:macro-dsl:syntax}

\annotation{typestate}'s DSL syntax is interlinked with its automaton extraction process,
hence I will discuss them in conjunction.
As we go, I will present parts of the syntax and explain how it relates with the automaton.
We will reuse the vending machine example, illustrated in \autoref{fig:vending-machine} and model it using our DSL.

\paragraph{The \annotation{typestate} macro} is the DSL's entrypoint and
it only supports being attached to modules.
Given that we want to access several parts of Rust's syntax \eg{\keyword{struct}, \keyword{enum}, etc} we can take one of two approaches ---
either analyze the whole file, or annotate and process the best next thing, the module.

The module provides most of the syntax elements available to \quotes{top-level} Rust,
while being possible to analyze using the macro system;
inside a module we can declare structures, enumerations, free functions and so on.

To start modeling the vending machine we first declare a module, to which we will call \texttt{vending\_machine\_api},
and annotate it with \annotation{typestate}; as shown in \autoref{lst:vending-machine-typestate-module}.
This alone is not enough, as the macro will throw an error due to the lack of an automaton; shown in \autoref{lst:vending-machine-typestate-missing-automaton-error}.

\begin{listing}
    \begin{minted}[linenos=false]{Rust}
#[typestate] mod vending_machine_api {}
    \end{minted}
    \caption{The vending machine's \gls{API} module, annotated with the \annotation{typestate} macro.}
    \label{lst:vending-machine-typestate-module}
\end{listing}

\begin{listing}
    \begin{minted}[linenos=false]{text}
error: Missing `#[automaton]` struct.
    |
    | #[typestate]
    | ^^^^^^^^^^^^
    \end{minted}
    \caption{The error issued by the code in \autoref{lst:vending-machine-typestate-module}.}
    \label{lst:vending-machine-typestate-missing-automaton-error}
\end{listing}

\paragraph{The \annotation{automaton} annotation} is attachable to structures only, % TODO check this
and allows the macro to know which of the declared structures is the automaton.

\autoref{lst:vending-machine-typestate-module-automaton} fixes the error of \autoref{lst:vending-machine-typestate-module},
by adding the \texttt{VendingMachine} structure and annotating it with \annotation{automaton}
the macro is now able to know which structure is the main state machine \ie{which structure will be \quotes{typestated}}.

\begin{listing}
    \begin{minted}[linenos=false]{Rust}
#[typestate] mod vending_machine_api {
    #[automaton] pub struct VendingMachine;
}
    \end{minted}
    \caption{\autoref{lst:vending-machine-typestate-module}; with an automaton declaration.}
    \label{lst:vending-machine-typestate-module-automaton}
\end{listing}

Notice how the code from \autoref{lst:vending-machine-typestate-module-automaton-expansion} does not contain any reference to the current state,
this is added by macro through the \annotation{automaton} annotation,
along with the sealed pattern skeleton, described in \autoref{sec:typestates-hard-way:future}.

\begin{listing}
    \begin{minted}[linenos=false]{Rust}
mod vending_machine_api {
    mod private {
        pub trait Sealed {}
    }
    pub trait State: private::Sealed {}
    pub struct VendingMachine<S> where S: State {
        state: S
    }
}
    \end{minted}
    \caption{Code resulting from \autoref{lst:vending-machine-typestate-module-automaton} expansion.}
    \label{lst:vending-machine-typestate-module-automaton-expansion}
\end{listing}

Once again, this still does not make the macro happy, while we now have an automaton, we are lacking initial and final states;
as shown in \autoref{lst:vending-machine-typestate-missing-states-error}.

\paragraph{The \annotation{state} annotation,} like the \annotation{automaton} annotation, is only attachable to structures;
it marks structures as states and also implements the necessary traits to include the state in the sealed trait state set (\autoref{sec:typestates-hard-way:future}).

As we can observe in \autoref{lst:vending-machine-typestate-module-states},
declaring states is as simple as attaching the annotation to an existing structure.
In \autoref{lst:vending-machine-typestate-module-states-expansion} we can see the expansion of the \texttt{NeedMoney} state;
implementing the sealed trait pattern.

\begin{listing}
    \begin{minted}[linenos=false]{Rust}
#[typestate] mod vending_machine_api {
    #[automaton] pub struct VendingMachine;
    #[state] pub struct Waiting;
    #[state] pub struct HasMoney { money: u64 }
    #[state] pub struct HasPick { picked_slot: usize }
    #[state] pub struct Finish;
    #[state] pub struct NeedMoney {
        pub money: u64,
        pub picked_slot: usize,
    }
}
    \end{minted}
    \caption{\autoref{lst:vending-machine-typestate-module-automaton}; with all states declared.}
    \label{lst:vending-machine-typestate-module-states}
\end{listing}

\begin{listing}
    \begin{minted}[linenos=false]{Rust}
mod vending_machine_api {
    // ...
    pub struct NeedMoney {
        pub money: u64,
        pub picked_slot: usize,
    }
    // using the qualified path (i.e. `private::Sealed`) we sidestep the
    // requirement of being *inside* the `private` module
    // to implement the `Sealed' trait
    impl private::Sealed for NeedMoney {}
    impl State for NeedMoney {}
}
    \end{minted}
    \caption{Expansion of the \texttt{NeedMoney} state, declared in \autoref{lst:vending-machine-typestate-module-states}.}
    \label{lst:vending-machine-typestate-module-states-expansion}
\end{listing}

While we have declared our states, we still have the same error (\autoref{lst:vending-machine-typestate-missing-states-error});
that is because, currently, we only have loose states, we have not connected them in any meaningful way.

\begin{listing}
    \begin{minted}[linenos=false]{text}
error: Missing initial state. To declare an initial state you can use a
function with signature like `fn f() -> T` where `T` is a declared state.
--> vm-typestate/src/main.rs:15:1
    |
    | #[typestate]
    | ^^^^^^^^^^^^
    |

error: Missing final state. To declare a final state you can use a
function with signature like `fn f(self) -> T` where `T` is not a declared state.
--> vm-typestate/src/main.rs:15:1
    |
    | #[typestate]
    | ^^^^^^^^^^^^
    |
    \end{minted}
    \caption{The error issued by the code in \autoref{lst:vending-machine-typestate-module}.}
    \label{lst:vending-machine-typestate-missing-states-error}
\end{listing}


\paragraph{Function declarations} allow us to declare transitions without any kind of annotations;
we can simply look at the function signature and infer the kind of transition,
however to do so, we first need to establish rules, those are:

\begin{compactitem}
    \item If a function takes \keyword{self} and returns a valid state,
    the function is considered to be a transition between the current state and the returned state.
    \begin{minted}[linenos=false]{Rust}
fn (self, ...) -> State;
    \end{minted}
    \item If a function \emph{does not} take \keyword{self} as an argument and returns the current state,
    it describes the current state as an initial state.
    \begin{minted}[linenos=false]{Rust}
fn (...) -> State;
    \end{minted}
    \item If a function takes \keyword{self} as an argument and \emph{does not} return a valid state,
    it describes the consumed state as a final state.
    \begin{minted}[linenos=false]{Rust}
fn (self, ...) -> ...;
    \end{minted}
\end{compactitem}

To declare functions, we first need to declare a \keyword{trait} with the same name as the target state,
by doing this, the macro is able to know which state we are currently referring to;
inside the trait, we can declare all functions to be implemented by the current state.

If the reader is familiarized with Rust, they might have realized that traits cannot share names with structures,
enumerations or others; in our DSL that works because during expansion the trait is renamed as: \texttt{TraitName + State => TraitNameState}.

In \autoref{lst:vending-machine-typestate-module-transitions},
we use the \texttt{Waiting} state as it contains all the previously described types of transitions.

\begin{listing}
    \begin{minted}[linenos=false]{Rust}
#[typestate] mod vending_machine_api {
    #[state] pub struct Waiting;
    // The trait is named after the `Waiting` state,
    // thus, the macro knows which state is the *current* one.
    pub trait Waiting {
        // Does not consume self, returns the current state: initial state
        fn on() -> Waiting;
        // Consumes self, does not return: final state
        fn off(self);
        // Consume self and return a valid state: transitions
        fn insert_money(self, money: u64) -> HasMoney;
        fn pick_slot(self, picked_slot: usize) -> HasPick;
    }
}
    \end{minted}
    \caption{Declaration of the \texttt{Waiting} state functions.}
    \label{lst:vending-machine-typestate-module-transitions}
\end{listing}

\paragraph{Implementing} the states and transitions is similar to what we did in \autoref{sec:typestates-hard-way},
while we have taken care of the sealed pattern, how the machine behaves is left to us.

When using the DSL, instead of declaring an implementation for the target state, as follows:
\begin{minted}[linenos=false]{rust}
impl VendingMachine<Waiting> { /* ... */ }
\end{minted}

You implement a trait for the target state:
\begin{minted}[linenos=false]{rust}
impl WaitingState for VendingMachine<Waiting> { /* ... */ }
\end{minted}

This way, the compiler is able to point out which methods are missing
(and in the future, tools like \texttt{rust-analyzer}\footnote{\url{https://rust-analyzer.github.io/}} might add all missing signatures for the developer).
The rest of the implementation is made in the same way as the one in \autoref{sec:typestates-hard-way}.


\subsubsection{Summary}

In \autoref{sec:macro-dsl:syntax} I have introduced the basic features of the DSL;
in \autoref{tab:dsl-summary-annotations} I provide a quick overview of the available annotations,
\annotation{typestate}, \annotation{automaton} and \annotation{state};
in \autoref{tab:dsl-summary-functions} I review the transition inference rules for function declarations.

% TODO: complete the summary

\begin{table}
    \centering
    \begin{tabular}{l|l|l}
        Annotation             & Attaches to & Declares            \\
        \hline
        \annotation{typestate} & Module      & API                 \\
        \hline
        \annotation{automaton} & Structure   & Automaton/Typestate \\
        \hline
        \annotation{state}     & Structure   & State
    \end{tabular}
    \caption{Overview of the DSL's annotations.}
    \label{tab:dsl-summary-annotations}
\end{table}

\begin{table}
    \centering
    \begin{tabular}{l|c|c|l}
        Function signature                & Consumes a state & Returns a state & Inferred      \\
        \hline
        \texttt{fn (self, ...) -> State;} & \checkmark       & \checkmark      & Transition    \\
        \hline
        \texttt{fn (...) -> State;}       &                  & \checkmark      & Initial State \\
        \hline
        \texttt{fn (self, ...) -> ...;}   & \checkmark       &                 & Final State
    \end{tabular}
    \caption{Overview of the transition inference rules.}
    \label{tab:dsl-summary-functions}
\end{table}


\subsection{Advanced Features}\label{sec:macro-dsl:advanced}

In \autoref{sec:macro-dsl:syntax} we have learned about the basic features of the DSL,
armed with them, the reader should be able to write typestates.
However, some typestates will require more complex mechanisms, both to develop and use,
that is the purpose of this section.

Once more, we will expand on the vending machine example; illustrated in \autoref{fig:vending-machine}.

\section{Validation}\label{sec:validation}

\subsection{Typestate}\label{sec:validation:typestate}

\subsection{Automaton \& Graph}\label{sec:validation:automaton}

\section{Extra Features}\label{sec:extra-features}

\subsection{Automata Visualization}\label{sec:extra-features:automata-visualization}

\subsection{Documentation Generation}\label{sec:extra-features:documentation-generation}

%!TEX root = ../template.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% abstrac-en.tex
%% NOVA thesis document file
%%
%% Abstract in English([^%]*)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\typeout{NT FILE abstract-en.tex}

As software becomes more prevalent in our lives, bugs are able to cause significant disruption.
Thus, preventing them becomes a priority when trying to develop dependable systems.
While reducing their occurrence possibility to zero is infeasible,
existing approaches are able to eliminate certain subsets of bugs.

Rust is a systems programming language that addresses memory-related bugs by design,
eliminating bugs like \emph{use-after-free}.
To achieve this, Rust leverages the type system along with information about object lifetimes,
allowing the compiler to keep track of objects throughout the program and checking for memory misusage.
While preventing memory-related bugs goes a long way in software security, other categories of bugs remain in Rust.
One of which would be \gls{API} misusage, where the developer does not respect constraints put in place by an \gls{API},
thus resulting in the program crashing.

Typestates elevate state to the type level, allowing for the enforcement of \gls{API} constraints at compile-time.
Relieving the developer from the burden that is keeping track of the possible computation states at runtime,
preventing possible \gls{API} misusage during development.
While Rust does not support typestates by design,
the type system is powerful enough to express and validate typestates.

I propose a new macro-based approach to deal with typestates in Rust,
this approach provides an embedded DSL which allows developers to express typestates using only existing Rust syntax;
furthermore, Rust's macro system is leveraged extract a state machine out of the typestate specification and
then perform compile-time checks over the typestate specification,
afterwards we leverage Rust's type system to check protocol-compliance for us.
The DSL avoids workflow-bloat by requiring nothing but a Rust compiler and the library itself.

% This thesis' goal is to bridge the gap between typestates and production Rust,
% developing a practical tool enabling programmers to take advantage of typestates in their Rust code.
% The tool takes the form of an embedded DSL backed by Rust macros,
% keeping the approach grounded in Rust syntax and easy to use.
% The developer specifies typestates through the use of special annotations in the code.
% From the specification, a state machine is extracted and checked for common typestate pitfalls,
% thus providing correctness properties beyond simple typestates.
% The tool, leveraging on Rust's type system, statically ensures the compliance of the code regarding the typestate.

\begin{keywords}
Behavioral types, typestates, meta-programming, macros, Rust
\end{keywords}
